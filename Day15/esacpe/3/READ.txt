bootpack.c

fifoで送ったデータの数値
0~1	 カーソル点滅用タイマ
3	3秒タイマ
10	10秒タイマ
256~511	キーボード入力(キーボードコントローラーから読んだ値に256を足す)
512~767	マウス入力(キーボードコントローラーから読んだ値に512を足す)


arはセグメント属性

ここでマルチタスクになる
タスク＝アプリと考えても良い
gdb+１は全体を示している
gdb+2はOSについてのセグメントであることを示している

TSS(タスク状態セグメント)というセグメントが通常使われているOSには実装されている

これは該当するタスクに関してのレジスタの内容を指定された場所のメモリ(TSSセグメントの領域)に書かれているセグメント(メモリの領域を事前に決めたもの)である

ここでタスクをスイッチさせるやり方は、JMP命令をしているだけ(farモード)

farモードはEIP(次に命令を実行するためのメモリの番地を記憶しておくためのレジスタ)とCS(コードセグメントレジスタ)

ここでJMP命令した際に実行可能なセグメントではなく、TSSだった場合にはタスクスイッチ命令だと判断。その後TSSで指定されたタスクに切り替わる。


（ここからはマルチタスク、つまりアプリのようなものを動かすためにメモリ管理が必要となる
そこでマルチタスクを行うためにタスクスイッチというものがあり、それはセグメントが必要となるためここであらたにｇｄｂを増やしている）

セグメントの場所を決めるのがセグメントレジスタである。
それぞれ、CS、DS、SS、ES、FS、GSがある。
コードセグメントはCSであり、これらはプログラムの命令がおいてある場所を指定セ
グメント

データセグメント（DS、ES、FS、GS）：データが置いてある場所を指定するセグメント

EIPレジスタ(IPレジスタ)は次に実行する命令がどこにあるかをメモリのどの番地にあるかを格納するレジスタ

load_trは現在動いているタスク(ここではbootのmain)がGDTの３番めであると設定している。

ちなみにTSSを作る順番は下から上に作られるので現環境だとtss_aが0x30fbecから103バイト分作成後、tss_bが30fb84から作られている


順番:

①:まず最初にタスクAが実行されている(load_tr(3*8)によりセグメント3番目がタスクAであるため)

②:ここでif(i==10)の部分でtaskswitch4が実行される。taskswitch4はタスクを変えるものであり、JMP命令が行われる。ここでセグメントの４番目に移動するようにしてある。ここでタスクBが実行される(タスクBはセグメントの４番目に指定されているため)

③:タスクBの設定でレジスタに入れる情報の中でCSがGDTの２番目を指定しているが、これはタスクBで実行されるコードであるtask_b_mainがbootpack.cにかかれており、この部分はセグメントの２番目にあたるためである。

④:task_b_mainは何もしないまま、ただループをするだけなので割り込みをすることができないようになっている(_io_hlt)



15-3

ここではタスクスイッチを0.02秒ごとに行っている
ここの内容確認を次で確認

